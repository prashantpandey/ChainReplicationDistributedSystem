import sys
import json
import pickle
import re

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# JSON decoder class for reading and parsing json objects from file
class ConcatJSONDecoder(json.JSONDecoder):
    def decode(self, s, _w=WHITESPACE.match):
        s_len = len(s)

        objs = []
        end = 0
        while end != s_len:
            obj, end = self.raw_decode(s, idx=_w(s, end).end())
            end = _w(s, end).end()
            objs.append(obj)
        
        return objs


# Server class for handling requests from client
class Server(process):
    # setup the server process
    def setup(clients, config, pred, succ):
        self.serverId = config['serverId']
        self.accDetails = {}
        self.history = {}
        self.sentReq = {}
        self.clientProcessList = list(clients)

    # main function
    # a place holder to keep the server alive
    def main():
        output("ServerId: " + str(serverId) + " starting the server operations")
        await(False)

    # callback function to handle the query requests from the client
    # must be the tail server ih the chain
    def receive(msg=('Query', req), from_=p):
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        output("ServerId: " + str(serverId) + " Received Query request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        num = req['accNum']
        res = {}
        res['reqId'] = req['reqId']
        res['outcome'] = 'Processed'
        if num in accDetails:
            res['currBal'] = accDetails[num]
        else:
            output("Account does not exists. Creating new account")
            accDetails[num] = 0
            res['currBal'] = 0
        send(('Response',res), to=p)        # send the response back to the client

    # callback function to handle the update requests from the clients
    # must be the head server in the chain
    def receive(msg=('Update', req), from_=p):
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        output("ServerId: " + str(serverId) + " Received Update request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        num = req['accNum']
        amt = req['amount']
        reqId = req['reqId']
        res = {}
        res['reqId'] = reqId
        if num in accDetails:
            bal = accDetails[num]
            if req['operation'] == 1:
                accDetails[num] = bal + amt
                output("ServerId: " + str(serverId) + " Updating the bal: " + str(bal + num))
                res['outcome'] = 'Processed'
            elif req['operation'] == 2:
                if(bal < amt):
                    output("ServerId: " + str(serverId) + " Not sufficient balance")
                    res['outcome'] = 'InsufficientBalance'
                else:
                    accDetails[num] = bal - amt
                    res['outcome'] = 'Processed'
        else:
            output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
            accDetails[num] =  amt
            res['outcome'] = 'Processed'
        res['currBal'] = accDetails[num]
        res['payload'] = req
        history[reqId] = req            # add request to the history object
        sentReq[reqId] = req            # add request to the sent object
        send(('Sync', res), to=succ)    # send Sync request

    # callback function to handle the Sync request from successor
    def receive(msg=('Sync', req), from_=p):
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        output("ServerId: " + str(serverId) + " Received Sync request: " + str(req['reqId']))
        num = req['payload']['accNum']
        reqId = req['reqId']
        clientId = req['payload']['clientId']
        accDetails[num] = req['currBal']
        history[reqId] = req['payload']
        sentReq[reqId] = req['payload']
        if config['type'] == 2:
            client = clientProcessList[clientId]
            del req['payload']
            res = req
            send(('Response', res), to=client)          # send reponse back to client 
            send(('Ack', reqId, serverId), to=pred)     # send ack back to the predecessor
        else:
            send(('Sync', req), to=succ)                # send Sync request to the successor
    
    # callback method to handle the Ack request from the predecessor
    # will delete the requests smaller than the received "reqId" from sent list
    def receive(msg=('Ack', reqId, serverId), from_=p):
        output("ServerId: " + str(serverId) + " " + str(reqId))
        output("ServerId: " + str(serverId) + " Received Ack request: " + str(reqId))
        for key in range(0, reqId):
            if key in sentReq:
                del sentReq[key]
        
# Client class for performing operations on server
class Client(process):
    # setup function for the client process
    def setup(servers, config, data):
        self.clientId = config['clientId']
        self.serverProcessList = list(servers)
        self.lastRecv = 0
        self.responses = []

    # will return the process corresponding to the 
    # head/tail server of the given bank
    def findServer(opr, bankId):
        if opr == 0:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['tailServer']
        else:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['headServer']

    # main function to read the payload file and
    # invoke requests to the server
    def main():
        output("ClientId: " + str(clientId) + " starting the client operations")
        for d in data:
            for item in d['data']:
                if clientId == item['clientId']:
                    for payload in item['payloads']:
                        # output("payload: " + json.dumps(payload['payload']))
                        req = payload['payload']
                        req['clientId'] = clientId
                        reqId = req['reqId']
                        type = ''
                        if req['operation'] == 0:
                            type = 'Query'
                        else:
                            type = 'Update'
                        clk = logical_clock()
                        await(lastRecv == (reqId - 1))
                        output("ClientId: " + str(clientId) + " Sending request to server: " + str(req['reqId']))
                        idx = findServer(req['operation'], req['bankId'])
                        p = serverProcessList[idx] 
                        send((type, req), to=p)
        await(False)            # will keep the client process alive

    # callback function to recieve the reponse back from the server
    # will append the response to the "responses" list
    def receive(msg=('Response', res)):
        output("ClientId: " + str(clientId) + " Received response from server for request: " + str(res['reqId']))
        output("ClientId: " + str(clientId) + " Current Balance: " + str(res['currBal']))
        responses.append(res)           # add the received response to the responses object
        lastRecv = res['reqId']
        output("Responses: " + json.dumps(responses))


# count number of client and server processes
# using the config file
def countProcesses(config):
    count = {}
    servers = 0
    for c in config:
        for bank in c['bank']:
            servers += len(bank['servers'])
        count['total_servers'] = servers
        count['total_clients'] = len(c['client'])
    print('Bootstraping: Calculating #  of processes: ' + json.dumps(count))
    return count

# main function for bootstraping the servers and clients
def main():
    config(clock='Lamport')

    print('Bootstraping: loading and parsing the config file')
    # load and parse the 'config' and 'payload' files in JSON format

    dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/payload.json')
    data = json.load(dataFile, cls=ConcatJSONDecoder)
    cfgFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/config.json')
    config = json.load(cfgFile, cls=ConcatJSONDecoder)
    
    # calculate the number of client and servers needed
    count = countProcesses(config)
    
    # create the respective # of processes
    servers = new(Server, num = count['total_servers'])
    clients = new(Client, num = count['total_clients'])

    # create a list of clients config objects
    clientMap = []
    for c in config:
        for client in c['client']:
            clientMap.append(client)

    # create a list of server config objects
    serverMap = []
    for c in config:
        for bank in c['bank']:
            for s in bank['servers']:
                conf = {}
                conf['bankId'] = bank['bankId']
                conf['type'] = s['type']
                conf['serverId'] = s['serverId']
                serverMap.append(conf) 

    # setup servers/clients
    print('Bootstraping: Setting up client/server processes')
    i = 0
    serList = list(servers)
    for process, config in zip(serList, serverMap):
        if config['type'] == 0:
            setup({process}, (clients, config, None, serList[i+1]))
        elif config['type'] == 2:
            setup({process}, (clients, config, serList[i-1], None))
        else:
            setup({process}, (clients, config, serList[i-1], serList[i+1]))
        i += 1

    # setup the client processes
    # the "clientId" of the client will be the index of the 
    # client process in the "clients" list
    cltList = list(clients)
    for process, config in zip(cltList, clientMap):
        setup({process}, (servers, config, data))

    print('Bootstraping: Starting client/server processes')
    # Start the server and client processes
    start(servers)
    start(clients)

