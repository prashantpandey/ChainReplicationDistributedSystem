import time
import threading
import sys
import heapq
import json
import pickle
import re

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# JSON decoder class for reading and parsing json objects from file
class ConcatJSONDecoder(json.JSONDecoder):
    def decode(self, s, _w=WHITESPACE.match):
        s_len = len(s)
        objs = []
        end = 0
        while end != s_len:
            obj, end = self.raw_decode(s, idx=_w(s, end).end())
            end = _w(s, end).end()
            objs.append(obj)
        return objs


# Server class for handling requests from client
class Server(process):
    # setup the server process
    def setup(clients, config, pred, succ):
        self.serverId = config['serverId']
        self.accDetails = {}
        self.history = {}
        self.sentReq = []
        self.clientProcessList = list(clients)

    # main function
    # a place holder to keep the server alive
    def main():
        output("ServerId: " + str(serverId) + " starting the server operations")
        await(False)

    # callback function to handle the query requests from the client
    # must be the tail server ih the chain
    def receive(msg=('Query', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Query request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        reqId = req['reqId']
        res = {}
        flag = True

        # output(json.dumps(history)) 
        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Query request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Query request already inconsistent with history: " + json.dumps(res))
        else:
            res['reqId'] = reqId
            res['outcome'] = 'Processed'
            res['accNum'] = num
            if num in accDetails:
                res['currBal'] = accDetails[num]
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                # don't create the account on tail, if one doesn't exist
                # accDetails[num] = 0
                res['currBal'] = 0
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res
            history[reqId] = hist
        send(('Response',res), to=p)        # send the response back to the client

    # callback function to handle the update requests from the clients
    # must be the head server in the chain
    def receive(msg=('Update', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Update request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        amt = req['amount']
        oper = req['operation']
        reqId = req['reqId']
        res = {}
        flag = True

        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num and hist['payload']['operation'] == oper and hist['payload']['amount'] == amt:
            #if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Update request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Update request inconsistent with history: " + json.dumps(res))
            send(('Response', res), to=p)    # send the response back to client
        else:
            res['reqId'] = reqId
            res['accNum'] = num
            if num in accDetails:
                bal = accDetails[num]
                if req['operation'] == 1:
                    accDetails[num] = bal + amt
                    output("ServerId: " + str(serverId) + " Updating the bal: " + str(bal + num))
                    res['outcome'] = 'Processed'
                elif req['operation'] == 2:
                    if(bal < amt):
                        output("ServerId: " + str(serverId) + " Not sufficient balance")
                        res['outcome'] = 'InSufficientFunds'
                    else:
                        accDetails[num] = bal - amt
                        res['outcome'] = 'Processed'
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                if req['operation'] == 1:
                    accDetails[num] =  amt
                    res['outcome'] = 'Processed'
                else:
                    accDetails[num] =  0
                    res['outcome'] = 'InSufficientFunds'
            res['currBal'] = accDetails[num]
            res['payload'] = req
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res 
            history[reqId] = hist            # add request to the history object
            # sentReq[reqId] = req            # add request to the sent object
            sentReq.append({reqId:req})            # add request to the sent object
            send(('Sync', res), to=succ)    # send Sync request

    # callback function to handle the Sync request from successor
    def receive(msg=('Sync', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Sync request: " + str(req['reqId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['payload']['accNum']
        reqId = req['reqId']
        clientId = req['payload']['clientId']
        accDetails[num] = req['currBal']
        history[reqId] = req['payload']
        sentReq.append({reqId:req['payload']})
        if config['type'] == 2:
            client = clientProcessList[clientId]
            del req['payload']
            res = req
            send(('Response', res), to=client)          # send reponse back to client 
            send(('Ack', reqId, serverId), to=pred)     # send ack back to the predecessor
        else:
            send(('Sync', req), to=succ)                # send Sync request to the successor
    
    # callback method to handle the Ack request from the predecessor
    # will delete the requests smaller than the received "reqId" from sent list
    def receive(msg=('Ack', reqId, serverId), from_=p):
        output("ServerId: " + str(serverId) + " Received Ack request: " + str(reqId))
        # output("ServerId: " + str(serverId) + " " + str(reqId))
        
	#nums = reqId.split(".")
        #for i in range(0, int(nums[1])):
        #    key = nums[0] + '.' + str(i)
        #    if key in sentReq:
        #        del sentReq[key]
    
	#for i in range(0, len(sentReq)):
	#    if (sentReq[i] == reqId):
	#	sentReq = sentReq[i:]

    # Successor being notified about its predecessor
    # Successor sends the last seqNum to the master which is used by predecessor
    # to send back the requests not received by the successor
    def receive(msg=('notifySucc', res), from_=p):
	# TODO:: does successor need to do anything with the new predecessor?
	send(('seqNum', sentReq[-1]), to=master) 


    # Predecessor being notified about its predecessor
    # Predecessor sends the all the requests greater than seqNum to the successor
    def receive(msg=('notifyPred', res), from_=p):
	seqNum = res['seqNum']
	succId = res['serverId']
	for i in range(0,len(sentReq)):
	    if i[seqNum]:
		break
	for j in range(i,len(sentReq)):
	    send(('seqNumToSucc', sentReq[i]), to=succId)
	
    # Successor updates its sentReq to reflect all the seqNum which are being sent by predecessor
    def receive(msg=('seqNumToSucc', res), from_=p):
	sentReq.append(res)
        

# Client class for performing operations on server
class Client(process):
    # setup function for the client process
    def setup(servers, config, data):
        self.clientId = config['clientId']
        self.serverProcessList = list(servers)
        self.lastRecv = '0.0'
        self.numsLR = lastRecv.split(".")
        self.responses = {}

    # will return the process corresponding to the 
    # head/tail server of the given bank
    def findServer(opr, bankId):
        if opr == 0:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['tailServer']
        else:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['headServer']

    # main function to read the payload file and
    # invoke requests to the server
    def main():
        output("ClientId: " + str(clientId) + " starting the client operations")
        for d in data:
            for item in d['data']:
                if clientId == item['clientId']:
                    for payload in item['payloads']:
                        # output("payload: " + json.dumps(payload['payload']))
                        req = payload['payload']
                        req['clientId'] = clientId
                        reqId = req['reqId']
                        type = ''
                        if req['operation'] == 0:
                            type = 'Query'
                        else:
                            type = 'Update'
                        clk = logical_clock()
                        nums = reqId.split(".")
                        if int(nums[1]) > 1:
                            await(lastRecv in responses)                   
                        """
                        if int(nums[1]) > 1:
                            # output("ReqId: " + reqId + " LastReqId: " + lastRecv)
                            await(int(numsLR[1]) == int(nums[1]) - 1)
                        """
                        idx = findServer(req['operation'], req['bankId'])
                        p = serverProcessList[idx] 
                        output("ClientId: " + str(clientId) + " Sending request:" + str(req['reqId']) + " to server: " + str(idx))
                        send((type, req), to=p)
                        lastRecv = reqId

        await(False)            # will keep the client process alive

    # callback function to recieve the reponse back from the server
    # will append the response to the "responses" list
    def receive(msg=('Response', res)):
        output("ClientId: " + str(clientId) + " Received response from server for request: " + str(res['reqId']))
        output("ClientId: " + str(clientId) + " Current Balance: " + str(res['currBal']))
        responses[res['reqId']] = res           # add the received response to the responses object
        #lastRecv = res['reqId']
        #numsLR = lastRecv.split(".")
        # output("last received updated: " + lastRecv)
        output("ClientId: " + str(clientId) + " Responses: " + json.dumps(responses))
    
    def receive(msg=('notifyClient',res)):
	output("ClientId: " + str(clientId) + "Notified about the "+ str(serverId) + "failure.")
	# Update client structures to let know the new bank head/tail
	# TODO:: As the serverMap has been updated, client would not have to do anything. Right?
	

# count number of client and server processes
# using the config file
def countProcesses(config):
    count = {}
    servers = 0
    for c in config:
        for bank in c['bank']:
            servers += len(bank['servers'])
        count['total_servers'] = servers
        count['total_clients'] = len(c['client'])
    print('Bootstraping: Calculating #  of processes: ' + json.dumps(count))
    return count

# main function for bootstraping the servers and clients
def main():
    config(clock='Lamport')

    print('Bootstraping: loading and parsing the config file')
    # load and parse the 'config' and 'payload' files in JSON format

    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/randomPayload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/samePayload.json')
    dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/payload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/inconsistentHistoryPayload.json')
    data = json.load(dataFile, cls=ConcatJSONDecoder)
    cfgFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/config.json')
    config = json.load(cfgFile, cls=ConcatJSONDecoder)
   
    # seqNum received from successor in case of internal server failure
    seqNum = -1
 
    # calculate the number of client and servers needed
    count = countProcesses(config)
    
    # create the respective # of processes
    servers = new(Server, num = count['total_servers'])
    clients = new(Client, num = count['total_clients'])

    # create the master process
    master = new(Master, num = 1)

    # create a list of clients config objects
    clientMap = []
    for c in config:
        for client in c['client']:
            clientMap.append(client)

    # create a list of server config objects
    serverMap = []
    for c in config:
        for bank in c['bank']:
            for s in bank['servers']:
                conf = {}
                conf['bankId'] = bank['bankId']
                conf['type'] = s['type']
                conf['serverId'] = s['serverId']
                serverMap.append(conf) 

    # create list of clients attached to bank
    # used by master to communicate about the failure of head/tail
    bankClientInfo = {}
    for c in config:
	for bank in c['bank']:
	    cliList = []
	    for cli in bank['clients']:
		cliList.append(cli['clientId'])
	    bankClientInfo[bank] = cliList		  
     
    # setup servers/clients
    print('Bootstraping: Setting up client/server processes')
    i = 0
    serList = list(servers)
    for process, config in zip(serList, serverMap):
        if config['type'] == 0:
            setup({process}, (clients, config, None, serList[i+1]))
        elif config['type'] == 2:
            setup({process}, (clients, config, serList[i-1], None))
        else:
            setup({process}, (clients, config, serList[i-1], serList[i+1]))
        i += 1

    # setup the client processes
    # the "clientId" of the client will be the index of the 
    # client process in the "clients" list
    cltList = list(clients)
    for process, config in zip(cltList, clientMap):
        setup({process}, (servers, config, data))

    print('Bootstraping: Starting client/server processes')
    # Start the server and client processes as well as the master
    start(servers)
    start(clients)
    start(master)

class GetTupleByTs(tuple):
     "tuple that sorts only on TS element"
     def __lt__(self, other):
         return self[2]<other[2]

# Master class for failure detection and chain extension

class Master(process):

    # setup function for the master process
    def setup():
	bankServerTupleList = []
	bankServerTsHeap = []
	pass

    # Make a bank server timestamp list where tuples are of the form (bankId, serverId, timestamp)
    # Make a heap of this list so as to check for server failures in O(1) time.
    # If a server entry is already there in the heap, just update the new timestamp when 
    # a heartbeat comes.
    # Else add a new entry for that server in the Server Timestamp list and the heap.

    def receive(msg=('HeartBeat', bankId, serverId), from_=p):
	flag = 0;
	output("Got a heartbeat message from server:" + str(serverId))
	#update the DS for the timestamp corresponding to that bank

	for x in bankServerTupleList:
	    if (serverId in x):
		bankServerTupleList.remove(x)
		bankServerTupleList.append((bankId, serverId, int(time.time())))
		flag = 1
		break;
	if flag == 0:
	    bankServerTupleList.append((bankId, serverId, int(time.time())))

        
	bankServerTsHeap = [GetTupleByTs(x) for x in bankServerTupleList] 
	output(bankServerTsHeap)
	heapq.heapify(bankServerTsHeap)
	output(heapq.heappop(bankServerTsHeap))

	return 0;

    # Checks the last timestamp(ts) using heappop() on bankServerTsHeap
    # If the ts > 5 seconds, then the server has failed.
    # Call the notify method accordingly.
    # This function executes every 1sec and probes the bankServerTsHeap to 
    # detect server failures.
    def probeServerForFailureCheck():
	# every 1 sec, master probes the heap structure to check if heartbeat has been 
	# received from servers or not.
	threading.Timer(1.0, printit).start()
	output("Detecting server failures if any!!");
	findFailure = 1
	while(findFailure) {
	    serverTsTuple = heapq.heappop(bankServerTsHeap)
	    if(int(time.time()) - serverTsTuple[2] > 5):
		output("Server with id" + serverTsTuple[1] + "has crashed!!!")
		handleServerFailure(bankId, serverId):
	   else
		findFailure = 0
	}

    # Handle the server failure by notifying the clients about the head/tail failures
    # and by notifying predecessor and successor about the internal server failure.     
    def handleServerFailure(bankId, serverId):
	# handle the failure of servers depending upon their type
	output("Handling server failure for server Id" + serverId)
	# TODO:: Find the server type

	for item in serverMap:
	    if (item['serverId'] == serverId && item['bankId'] == bankId):
		serverType = item['type']

	switch(serverType) {
	    case 0: 
		    # Head has failed. Notify the client about the new head server
		    newHead = updateChain(bankId, serverId, serverType)

		    payload['failure']['type'] = 0
		    payload['failure']['server'] = newHead[0]
		    payload['failure']['bankId'] = bankId
		    payload['failure']['seqNum'] = -1
		    
		    notifyClient(payload);
		    # notify the server with id newHead that it is the new head server
		    send(('notifyHead', payload), to=newHead)     
		    break

	    case 1:
		    
		    # Internal node has failed. Notify the predecessor and successor about it
		    newSuccPred = updateChain(bankId, serverId, serverType) 
		    
		    payload['failure']['type'] = 1
		    payload['failure']['server'] = newSuccPred[0]	    # is the new predecessor
		    payload['failure']['bankId'] = bankId
		    payload['failure']['seqNum'] = -1

		    # TODO:: How to notify the successor of its predecessor.
		    
		    # Send a 'notifySucc' message to the successor about its new predecessor
		    send(('notifySucc', payload), to=newSuccPred[1])
		    
		    # TODO:: wait for the successor to reply with seqNum
		    while(seqNum == -1) {
			sleep(1000)
		    }
		    payload['failure']['type'] = 1
		    payload['failure']['server'] = newSuccPred[1]	    # is the new successor
		    payload['failure']['bankId'] = bankId
		    payload['failure']['seqNum'] = seqNum
		    
		    # Send 'notifyPred' to the predecessor and send the seq retrieved from successor, so that the
		    prdecessor can send remaining messages with > seqNum to the new successor
		    send(('notifyPred', payload), to=newSuccPred[0])
		    break
							    
	    case 2:
		    
		    # Tail has failed. Notify the client about the new tail server
		    newTail = updateChain(bankId, serverId)
		    
		    payload['failure']['type'] = 2
		    payload['failure']['server'] = newTail[0]
		    payload['failure']['bankId'] = bankId
		    payload['failure']['seqNum'] = -1
		    
		    notifyClient(payload);
		    
		    # notify the server with id newTail that it is the new tail server
		    send(('notifyTail', payload), to=newTail)     
		    break;
	}

    # notify client of Head/Tail server failure of a bank
    def notifyClient(payload):
	# Retrieving all the clients of the bank whose server has failed
	bankId = payload['failure']['bankId'] 
	clientList = bankClientInfo[bankId]
	send(('notifyClient', bankId, payload), to=clientList)


    # Update the chain in case of server failures, the data structures containing this mapping
    # are modified. Returns a list of server, in case of new head [NewHead], internal server failure
    # [pred, succ] and in case of tail failure [newTail]
    def updateChain(bankId, serverId, type):
	output("Updating the chain after server failure!!")
	switch(serverType) {
	    case 0: # Head Failure
		    for item in serverMap:
			if item['bankId'] == bankId && item["type"] == type && item["serverId"] == serverId:
			    del item
			    flag = 1

			if flag == 1:		    # returning the next one as the new head
			    item['type'] = 0;
			    return [item['serverId']]
			    
	    case 1:
		    for item in serverMap:
			index++
			if item['bankId'] == bankId && item["type"] == type && item["serverId"] == serverId:
			    del item
			    flag = 1
			break
		    if flag == 1:
			pred = serverMap[index-1]['serverId'] 
			succ = serverMap[index+1]['serverId']
			if pred and succ:
			    return [pred, succ]
	    case 2:
		    index = 0
		    for item in serverMap:
			index++
			if item['bankId'] == bankId && item["type"] == type && item["serverId"] == serverId:
			    del item
			    break
		    # Update the previous entry in serverMap as the new tail
		    serverMap[index-1]['type'] = 2
		    return [serverMap[index-1]['serverId']]
	}
