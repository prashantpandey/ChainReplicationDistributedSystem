import time
import threading
import sys
import heapq
import json
import pickle
import re

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# JSON decoder class for reading and parsing json objects from file
class ConcatJSONDecoder(json.JSONDecoder):
    def decode(self, s, _w=WHITESPACE.match):
        s_len = len(s)
        objs = []
        end = 0
        while end != s_len:
            obj, end = self.raw_decode(s, idx=_w(s, end).end())
            end = _w(s, end).end()
            objs.append(obj)
        return objs


# Server class for handling requests from client
class Server(process):
    # setup the server process
    def setup(clients, config, pred, succ):
        self.serverId = config['serverId']
        self.accDetails = {}
        self.history = {}
        self.sentReq = {}
        self.clientProcessList = list(clients)

    # main function
    # a place holder to keep the server alive
    def main():
        output("ServerId: " + str(serverId) + " starting the server operations")
        await(False)

    # callback function to handle the query requests from the client
    # must be the tail server ih the chain
    def receive(msg=('Query', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Query request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        reqId = req['reqId']
        res = {}
        flag = True

        # output(json.dumps(history)) 
        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Query request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Query request already inconsistent with history: " + json.dumps(res))
        else:
            res['reqId'] = reqId
            res['outcome'] = 'Processed'
            res['accNum'] = num
            if num in accDetails:
                res['currBal'] = accDetails[num]
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                # don't create the account on tail, if one doesn't exist
                # accDetails[num] = 0
                res['currBal'] = 0
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res
            history[reqId] = hist
        send(('Response',res), to=p)        # send the response back to the client

    # callback function to handle the update requests from the clients
    # must be the head server in the chain
    def receive(msg=('Update', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Update request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        amt = req['amount']
        oper = req['operation']
        reqId = req['reqId']
        res = {}
        flag = True

        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num and hist['payload']['operation'] == oper and hist['payload']['amount'] == amt:
            #if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Update request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Update request inconsistent with history: " + json.dumps(res))
            send(('Response', res), to=p)    # send the response back to client
        else:
            res['reqId'] = reqId
            res['accNum'] = num
            if num in accDetails:
                bal = accDetails[num]
                if req['operation'] == 1:
                    accDetails[num] = bal + amt
                    output("ServerId: " + str(serverId) + " Updating the bal: " + str(bal + num))
                    res['outcome'] = 'Processed'
                elif req['operation'] == 2:
                    if(bal < amt):
                        output("ServerId: " + str(serverId) + " Not sufficient balance")
                        res['outcome'] = 'InSufficientFunds'
                    else:
                        accDetails[num] = bal - amt
                        res['outcome'] = 'Processed'
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                if req['operation'] == 1:
                    accDetails[num] =  amt
                    res['outcome'] = 'Processed'
                else:
                    accDetails[num] =  0
                    res['outcome'] = 'InSufficientFunds'
            res['currBal'] = accDetails[num]
            res['payload'] = req
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res 
            history[reqId] = hist            # add request to the history object
            sentReq[reqId] = req            # add request to the sent object
            send(('Sync', res), to=succ)    # send Sync request

    # callback function to handle the Sync request from successor
    def receive(msg=('Sync', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Sync request: " + str(req['reqId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['payload']['accNum']
        reqId = req['reqId']
        clientId = req['payload']['clientId']
        accDetails[num] = req['currBal']
        history[reqId] = req['payload']
        sentReq[reqId] = req['payload']
        if config['type'] == 2:
            client = clientProcessList[clientId]
            del req['payload']
            res = req
            send(('Response', res), to=client)          # send reponse back to client 
            send(('Ack', reqId, serverId), to=pred)     # send ack back to the predecessor
        else:
            send(('Sync', req), to=succ)                # send Sync request to the successor
    
    # callback method to handle the Ack request from the predecessor
    # will delete the requests smaller than the received "reqId" from sent list
    def receive(msg=('Ack', reqId, serverId), from_=p):
        output("ServerId: " + str(serverId) + " Received Ack request: " + str(reqId))
        # output("ServerId: " + str(serverId) + " " + str(reqId))
        nums = reqId.split(".")
        for i in range(0, int(nums[1])):
            key = nums[0] + '.' + str(i)
            if key in sentReq:
                del sentReq[key]

        
# Client class for performing operations on server
class Client(process):
    # setup function for the client process
    def setup(servers, config, data):
        self.clientId = config['clientId']
        self.serverProcessList = list(servers)
        self.lastRecv = '0.0'
        self.numsLR = lastRecv.split(".")
        self.responses = {}

    # will return the process corresponding to the 
    # head/tail server of the given bank
    def findServer(opr, bankId):
        if opr == 0:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['tailServer']
        else:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    return bank['headServer']

    # main function to read the payload file and
    # invoke requests to the server
    def main():
        output("ClientId: " + str(clientId) + " starting the client operations")
        for d in data:
            for item in d['data']:
                if clientId == item['clientId']:
                    for payload in item['payloads']:
                        # output("payload: " + json.dumps(payload['payload']))
                        req = payload['payload']
                        req['clientId'] = clientId
                        reqId = req['reqId']
                        type = ''
                        if req['operation'] == 0:
                            type = 'Query'
                        else:
                            type = 'Update'
                        clk = logical_clock()
                        nums = reqId.split(".")
                        if int(nums[1]) > 1:
                            await(lastRecv in responses)                   
                        """
                        if int(nums[1]) > 1:
                            # output("ReqId: " + reqId + " LastReqId: " + lastRecv)
                            await(int(numsLR[1]) == int(nums[1]) - 1)
                        """
                        idx = findServer(req['operation'], req['bankId'])
                        p = serverProcessList[idx] 
                        output("ClientId: " + str(clientId) + " Sending request:" + str(req['reqId']) + " to server: " + str(idx))
                        send((type, req), to=p)
                        lastRecv = reqId

        await(False)            # will keep the client process alive

    # callback function to recieve the reponse back from the server
    # will append the response to the "responses" list
    def receive(msg=('Response', res)):
        output("ClientId: " + str(clientId) + " Received response from server for request: " + str(res['reqId']))
        output("ClientId: " + str(clientId) + " Current Balance: " + str(res['currBal']))
        responses[res['reqId']] = res           # add the received response to the responses object
        #lastRecv = res['reqId']
        #numsLR = lastRecv.split(".")
        # output("last received updated: " + lastRecv)
        output("ClientId: " + str(clientId) + " Responses: " + json.dumps(responses))


# count number of client and server processes
# using the config file
def countProcesses(config):
    count = {}
    servers = 0
    for c in config:
        for bank in c['bank']:
            servers += len(bank['servers'])
        count['total_servers'] = servers
        count['total_clients'] = len(c['client'])
    print('Bootstraping: Calculating #  of processes: ' + json.dumps(count))
    return count

# main function for bootstraping the servers and clients
def main():
    config(clock='Lamport')

    print('Bootstraping: loading and parsing the config file')
    # load and parse the 'config' and 'payload' files in JSON format

    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/randomPayload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/samePayload.json')
    dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/payload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/inconsistentHistoryPayload.json')
    data = json.load(dataFile, cls=ConcatJSONDecoder)
    cfgFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/config.json')
    config = json.load(cfgFile, cls=ConcatJSONDecoder)
    
    # calculate the number of client and servers needed
    count = countProcesses(config)
    
    # create the respective # of processes
    servers = new(Server, num = count['total_servers'])
    clients = new(Client, num = count['total_clients'])

    # create the master process
    master = new(Master, num = 1)

    # create a list of clients config objects
    clientMap = []
    for c in config:
        for client in c['client']:
            clientMap.append(client)

    # create a list of server config objects
    serverMap = []
    for c in config:
        for bank in c['bank']:
            for s in bank['servers']:
                conf = {}
                conf['bankId'] = bank['bankId']
                conf['type'] = s['type']
                conf['serverId'] = s['serverId']
                serverMap.append(conf) 

    # create list of clients attached to bank
    # used by master to communicate about the failure of head/tail
    bankClientInfo = {}
    for c in config:
	for bank in c['bank']:
	    cliList = []
	    for cli in bank['clients']:
		cliList.append(cli['clientId'])
	    bankClientInfo[bank] = cliList		  
     
    # setup servers/clients
    print('Bootstraping: Setting up client/server processes')
    i = 0
    serList = list(servers)
    for process, config in zip(serList, serverMap):
        if config['type'] == 0:
            setup({process}, (clients, config, None, serList[i+1]))
        elif config['type'] == 2:
            setup({process}, (clients, config, serList[i-1], None))
        else:
            setup({process}, (clients, config, serList[i-1], serList[i+1]))
        i += 1

    # setup the client processes
    # the "clientId" of the client will be the index of the 
    # client process in the "clients" list
    cltList = list(clients)
    for process, config in zip(cltList, clientMap):
        setup({process}, (servers, config, data))

    print('Bootstraping: Starting client/server processes')
    # Start the server and client processes as well as the master
    start(servers)
    start(clients)
    start(master)

class GetTupleByTs(tuple):
     "tuple that sorts only on TS element"
     def __lt__(self, other):
         return self[2]<other[2]

# Master class for failure detection and chain extension
class Master(process):

    # setup function for the master process
    def setup():
	bankServerTupleList = []
	bankServerTsHeap = []
	pass

    # Make a bank server timestamp list where tuples are of the form (bankId, serverId, timestamp)
    # Make a heap of this list so as to check for server failures in O(1) time.
    # If a server entry is already there in the heap, just update the new timestamp when 
    # a heartbeat comes.
    # Else add a new entry for that server in the Server Timestamp list and the heap.
    def receive(msg=('HeartBeat', bankId, serverId), from_=p):

	flag = 0;
	output("Got a heartbeat message from server:" + str(serverId))
	#update the DS for the timestamp corresponding to that bank

	for x in bankServerTupleList:
	    if (serverId in x):
		bankServerTupleList.remove(x)
		bankServerTupleList.append((bankId, serverId, int(time.time())))
		flag = 1
		break;
	if flag == 0:
	    bankServerTupleList.append((bankId, serverId, int(time.time())))

        
	bankServerTsHeap = [GetTupleByTs(x) for x in bankServerTupleList] 
	output(bankServerTsHeap)
	heapq.heapify(bankServerTsHeap)
	output(heapq.heappop(bankServerTsHeap))

	return 0;

    # Checks the last timestamp(ts) using heappop() on bankServerTsHeap
    # If the ts > 5 seconds, then the server has failed.
    # Call the notify method accordingly.
    # This function executes every 1sec and probes the bankServerTsHeap to 
    # detect server failures.
    def probeServerForFailureCheck():
	# every 1 sec, master probes the heap structure to check if heartbeat has been 
	# received from servers or not.
	threading.Timer(1.0, printit).start()
	output("Detecting server failures if any!!");
	findFailure = 1
	while(findFailure) {
	    serverTsTuple = heapq.heappop(bankServerTsHeap)
	    if(int(time.time()) - serverTsTuple[2] > 5):
		output("Server with id" + serverTsTuple[1] + "has crashed!!!")
		handleServerFailure(bankId, serverId):
	   else
		findFailure = 0
	}

    # Handle the server failure by notifying the clients about the head/tail failures
    # and by notifying predecessor and successor about the internal server failure.     
    def handleServerFailure(bankId, serverId):
	# handle the failure of servers depending upon their type
	output("Handling server failure for server Id" + serverId)
	# TODO:: Find the server type

	for item in serverMap:
	    if (item['serverId'] == serverId && item['bankId'] == bankId):
		serverType = item['type']

	switch(serverType) {
	    case 0: 
		    # Head has failed. Notify the client about the new head server
		    newHead = updateChain(bankId, serverId, serverType)

		    payload['failure']['type'] = 0
		    payload['failure']['server'] = newHead
		    payload['failure']['bankId'] = bankId
		    
		    notifyClient(bankId, payload);
		    # notify the server with id newHead that it is the new head server
		    send(('notifyHead', payload), to=newHead)     
		    break

	    case 1:
		    
		    # Internal node has failed. Notify the predecessor and successor about it
		    newSuccPred = updateChain(bankId, serverId, serverType) 
		    
		    payload['failure']['type'] = 1
		    payload['failure']['server'] = newSuccPred
		    payload['failure']['bankId'] = bankId

		    # TODO:: How to notify the successor of its predecessor.
		    
		    # Notify the successor about its new predecessor and return the last seq
		    seqNum = notifyServer(bankId, payload, newSuccPred, -1)
		    
		    # Notify the predecessor and send the seq retrieved from successor, so that the
		    prdecessor can send remaining messages with > seqNumto the new successor
		    notifyServer(bankId, payload, newSuccPred, seqNum)
		    break
							    
	    case 2:
		    
		    # Tail has failed. Notify the client about the new tail server
		    newTail = updateChain(bankId, serverId)
		    
		    payload['failure']['type'] = 2
		    payload['failure']['server'] = newTail
		    payload['failure']['bankId'] = bankId
		    
		    notifyClient(bankId, payload, serverType);
		    
		    # notify the server with id newTail that it is the new tail server
		    send(('notifyTail', payload), to=newTail)     
		    break;
	}

    # notify client of Head/Tail server failure of a bank
    def notifyClient(bankId, serverId):
	# Retrieving all the clients of the bank whose server has failed
	clientList = bankClientInfo[bankId]
	send(('notifyClient', payload), to=clientList)

    def notifyServer(bankId, payload, serverId, seqNum):
	if seqNum == -1:
	    # has been called by a successor should return back its last seen SeqNum
	    # to master
	    # TODO:: retrieve the last seqNum from the sentReq
	    send(('notifySucc', payload), to=serverId)
	    # TODO:: wait for the successor to reply with seqNum
	    return seqNum
	
	elif seqNum >=1:
	    # has been called by prdecessor.
	    # send all the requests with sequence number greater than seqNum to successor.
	    send(('notifyPred', payload, seqNum), to=serverId)
	    
	pass

    # Update the chain in case of server failures, the data structures containing this mapping
    # are modified
    def updateChain(bankId, serverId, type):
	
	output("Updating the chain after server failure!!")
	switch(serverType) {
	
	    case 0: # Head Failure
		    for item in serverMap:
			if item['bankId'] == bankId && item["type"] == type:
			    item['serverId'] = serverId

		    # TODO:: Remove from the bankClientList
		    # also for anyserver type it would be same I think 		    
	    case 1:
	    case 2:
		    # Tail Failure
		    for item in serverMap:
			if item['bankId'] == bankId && item["type"] == type:
			    item['serverId'] = serverId
	
	}
