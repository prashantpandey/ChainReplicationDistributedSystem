import sys
import json
import pickle
import re
import itertools
import heapq
import time

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# JSON decoder class for reading and parsing json objects from file
class ConcatJSONDecoder(json.JSONDecoder):
    def decode(self, s, _w=WHITESPACE.match):
        s_len = len(s)
        objs = []
        end = 0
        while end != s_len:
            obj, end = self.raw_decode(s, idx=_w(s, end).end())
            end = _w(s, end).end()
            objs.append(obj)
        return objs


# Server class for handling requests from client
class Server(process):
    # setup the server process
    def setup(clients, master, config, pred, succ):
        self.serverId = config['serverId']
        self.startupDelay = config['startupDelay']
        self.serverLifeTime = config['serverLifeTime']
        self.extendChain = config['extendChain']
        self.accDetails = {}
        self.history = {}
        self.sentReq = []
        self.clientProcessList = list(clients)
        self.totalSentCnt = 0
        self.totalRecvCnt = 0
        self.lastSeqNum = 0

    # main function
    # a place holder to keep the server alive
    def main():
        if extendChain == 1:
            if await(False): pass
            elif timeout(startupDelay): pass        # wait for the startup delay
            contactMaster(config['bankId'])         # contact master for extending the chain    
            if await(extendChain == 0): pass           # await till the extend Chain operation completes

        output("ServerId: " + str(serverId) + " starting the server operations")
        heartBeatMsg = {}
        heartBeatMsg['serverId'] = serverId
        heartBeatMsg['bankId'] = config['bankId']
        heartBeatMsg['type'] = config['type']

        while True:                 # send heart beat msg to master every 2 secs
            if await(False): pass
            elif timeout(2):
                sendHeartBeatMsg(heartBeatMsg)
    
    def contactMaster(bankId):
        output("ServerId: "+ str(serverId) + " contacting master to extend chain")
        payload = {}
        payload['bankId'] = bankId
        payload['serverId'] = serverId
        data = {'extendChain' : payload}
        send(('AddToChain', data), to=master)
    
    def receive(msg=('ExtendChain', req), from_=p):
        output("ServerId: "+ str(serverId) + " handling extend chain") 
        if req['type'] == 2:                                            # Its the new tail
            config['type'] = 2
            pred = req['predecessor']
            output("ServerId: "+ str(serverId) + " activating as new tail and updated the predecessor")
            res = {}
            res['ack'] = 1
            # send(('ExtendChainAck', res), to=p)
            # output("ServerId: "+ str(serverId) + " sending ack to master")
        elif req['type'] == 1:                                          # Its the old tail
            output("ServerId: "+ str(serverId) + " Updating new successor and sync data with new tail")
            config['type'] = 1
            succ = req['successor']
            data = {}
            data['extendChain'] = 3
            data['accDetails'] = accDetails
            data['sentReq'] = sentReq
            data['history'] = history
            send(('ExtendChain', data), to=succ) 
        if req['extendChain'] == 3:     # Syncing data sent from the old tail 
            accDetails = data['accDetails']
            sentReq = data['sentReq']
            history = data['history']
            res = {}
            res['ack'] = 2
            output("ServerId: "+ str(serverId) + " Sync completed with old tail")
            send(('SyncComplete', res), to=p) 
            extendChain = 0
        if req['extendChain'] == -1:
            serverType = 2
            output("ServerId: "+ str(serverId) + " Old tail reveretd") 
            
    # Chec if the server life time is exceeded
    # if not then send heart beat signal to the master
    def sendHeartBeatMsg(msg):
        # check the server life time
        if 'UNBOUND' not in serverLifeTime:
            if 'RecvNum' in serverLifeTime.keys() and serverLifeTime['RecvNum'] == totalRecvCnt:
                output("ServerId: " + str(serverId) + " RECV request limit reached. Terminating server")
                sys.exit()
            elif 'SentNum' in serverLifeTime.keys() and serverLifeTime['SentNum'] == totalSentCnt:
                output("ServerId: " + str(serverId) + " SEND request limit reached. Terminating server")
                sys.exit()
        output("ServerId: " + str(serverId) + " sending heart beat to master")
        send(('HeartBeat', msg), to=master)

    # callback function to handle the query requests from the client
    # must be the tail server ih the chain
    def receive(msg=('Query', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Query request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        reqId = req['reqId']
        res = {}
        flag = True
        
        totalRecvCnt += 1       # increment total recv cnt
        # output(json.dumps(history)) 
        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Query request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Query request already inconsistent with history: " + json.dumps(res))
        else:
            res['reqId'] = reqId
            res['outcome'] = 'Processed'
            res['accNum'] = num
            if num in accDetails:
                res['currBal'] = accDetails[num]
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                # don't create the account on tail, if one doesn't exist
                # accDetails[num] = 0
                res['currBal'] = 0
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res
            history[reqId] = hist
          
        if(req['simFail'] == 2):
            output("ServerId: " + str(serverId) + " Simulating msg drop from server-client.")
            return
        send(('Response',res), to=p)        # send the response back to the client
        totalSentCnt += 1   # increment total sent cnt

    # callback function to handle the update requests from the clients
    # must be the head server in the chain
    def receive(msg=('Update', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Update request: " + str(req['reqId']) + " from client: " + str(req['clientId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['accNum']
        amt = req['amount']
        oper = req['operation']
        reqId = req['reqId']
        res = {}
        flag = True
        
        totalRecvCnt += 1   # increment total recv cnt
        if reqId in history:
            flag = False
            hist = history[reqId]
            if hist['payload']['accNum'] == num and hist['payload']['operation'] == oper and hist['payload']['amount'] == amt:
            #if hist['payload']['accNum'] == num:
                res = hist['response']
                output("ServerId: " + str(serverId) + " Update request already exists in history: " + json.dumps(res))
            else:
                res['reqId'] = reqId
                res['outcome'] = 'InconsistentWithHistory'
                res['accNum'] = num
                res['currBal'] = 0
                output("ServerId: " + str(serverId) + " Update request inconsistent with history: " + json.dumps(res))
            if req['simFail'] == 2:
                output("ServerId: " + str(serverId) + " Simulating msg drop from server-client.")
            else:
                send(('Response', res), to=p)    # send the response back to client
                totalSentCnt += 1   # increment total sent cnt
        else:
            res['reqId'] = reqId
            res['accNum'] = num
            if num in accDetails:
                bal = accDetails[num]
                if req['operation'] == 1:
                    accDetails[num] = bal + amt
                    output("ServerId: " + str(serverId) + " Updating the bal: " + str(bal + num))
                    res['outcome'] = 'Processed'
                elif req['operation'] == 2:
                    if(bal < amt):
                        output("ServerId: " + str(serverId) + " Not sufficient balance")
                        res['outcome'] = 'InSufficientFunds'
                    else:
                        accDetails[num] = bal - amt
                        res['outcome'] = 'Processed'
            else:
                output("ServerId: " + str(serverId) + " Account does not exists. Creating new account")
                if req['operation'] == 1:
                    accDetails[num] =  amt
                    res['outcome'] = 'Processed'
                else:
                    accDetails[num] =  0
                    res['outcome'] = 'InSufficientFunds'
            res['currBal'] = accDetails[num]
            res['payload'] = req
        
        if flag:
            hist = {}
            hist['payload'] = req
            hist['response'] = res 
            history[reqId] = hist            # add request to the history object
            sentReq.append(res)     # add the response to the sent list. Will be used in server failure
            send(('Sync', res), to=succ)    # send Sync request
            totalSentCnt += 1   # increment total sent cnt

    # callback function to handle the Sync request from successor
    def receive(msg=('Sync', req), from_=p):
        output("ServerId: " + str(serverId) + " Received Sync request: " + str(req['reqId']))
        output("ServerId: " + str(serverId) + " " + json.dumps(req))
        num = req['payload']['accNum']
        reqId = req['reqId']
        clientId = req['payload']['clientId']
        accDetails[num] = req['currBal']
        history[reqId] = { 'payload' : req['payload'], 'response' : req }
        sentReq.append(req)     # add the response to the sent list. Will be used in server failure
        totalRecvCnt += 1   # increment total recv cnt
        
        if config['type'] == 2:
            client = clientProcessList[clientId]
            if req['payload']['simFail'] == 2:
                output("ServerId: " + str(serverId) + " Simulating msg drop from server-client.")
            else:
                res = req
                del res['payload']
                send(('Response', res), to=client)          # send reponse back to client 
            send(('Ack', reqId, serverId), to=pred)     # send ack back to the predecessor
        else:
            send(('Sync', req), to=succ)                # send Sync request to the successor
        totalSentCnt += 1                               # increment total sent cnt
    
    # callback method to handle the Ack request from the predecessor
    # will delete the requests smaller than the received "reqId" from sent list
    def receive(msg=('Ack', reqId, serverId), from_=p):
        output("ServerId: " + str(serverId) + " Received Ack request: " + str(reqId))
        # output("ServerId: " + str(serverId) + " " + str(reqId))
        # nums = reqId.split(".")
        # for i in range(0, int(nums[1])):
        #    key = nums[0] + '.' + str(i)
        #    if key in sentReq:
        #        del sentReq[key] 
        for item in sentReq:
            if item['reqId'] == reqId:
                del item
    
    # callback handler for check log
    def receive(msg=('CheckLog', req), from_=p):
        reqId = req['reqId']
        res = {}
        output("ServerId: " + str(serverId) + " Processing check log for req: " + req['reqId'])
        if reqId in history.keys():
            res = history[reqId]['response']
            res['checkLog'] = 1
        else:
            res['checkLog'] = 0
            res['reqId'] = reqId
        output("ServerId: " + str(serverId) + " Processed check log for req: " + req['reqId'])
        send(('CheckLog', res), to=p)
    
    # callback function to handle the server failure request from master 
    # update the type if its head/tail server
    # update the succ/pred server in case of internal failure
    def receive(msg=('Failure', payload), from_=p):
        output("ServerId: " + str(serverId) + " handling the server failure")
        server = payload['failure']['server']
        type = payload['failure']['type']
        if type == "head":
            config['type'] = 0
            output("ServerId: " + str(serverId) + " updated the server type to HEAD")
        elif type == "tail":
            config['type'] = 2
            output("ServerId: " + str(serverId) + " updated the server type to TAIL")
        elif type == "successor":
            succ = server
            output("ServerId: " + str(serverId) + " updated the successor server")
            handleNewSucc(payload['failure']['seqNum'])
        elif type == "predecessor":
            pred = server
            res = { "seqNum" : lastSeqNum }
            send(('Failure', res), to=p)

           
    # handle internal server failure and resolve
    # sentReq anomalies by synchronizing the sentReq
    def handleNewSucc(seqNum):
        i = 0
        flag = False
        for item in sentReq: 
            i += 1
            if item['reqId'] == seqNum:
                flag = True
                break
        if flag == True:
            for j in range(i, len(sentReq)):
                send(('Sync', sentReq[j]), to=succ)
        else:
            for j in range(0, len(sentReq)):
                send(('Sync', sentReq[j]), to=succ)

        
# Client class for performing operations on server
class Client(process):
    # setup function for the client process
    def setup(servers, config, data):
        self.clientId = config['clientId']
        self.resendDelay = config['resendDelay']
        self.numRetries = config['numRetries']
        self.serverProcessList = list(servers)
        self.preReq = {}
        self.responses = {}
        self.currDelay = 0
        self.currRetriesCnt = 0
        self.retryLimit = True
        self.checkLogFlag = -1
        self.extendChainSleepFlag = -1
        self.bankServerMap = {}

    # will return the process corresponding to the 
    # head/tail server of the given bank
    def prepareServerMap(bankId):
        if bankId in bankServerMap.keys():
            return None
        else:
            for bank in config['banks']:
                if bankId == bank['bankId']:
                    bankServerMap[bankId] = {}
                    bankServerMap[bankId]['tailServer'] = bank['tailServer']
                    bankServerMap[bankId]['headServer'] = bank['headServer']
        output("ClientId: " + str(clientId) + " " + json.dumps(bankServerMap))
    
    def findServer(opr, bankId):
        if opr == 0 or opr == 4:
            return bankServerMap[bankId]['tailServer']
        else:
            return bankServerMap[bankId]['headServer']

    # main function to read the payload file and
    # invoke requests to the server
    def main(): 
        output("ClientId: " + str(clientId) + " starting the client operations")
        for d in data:
            for item in d['data']:
                if clientId == item['clientId']:
                    for payload in item['payloads']:
                        if await(False): pass
                        elif timeout(1): pass

                        # output("payload: " + json.dumps(payload['payload']))
                        req = payload['payload']
                        req['clientId'] = clientId
                        reqId = req['reqId']
                        type = ''
                        idx = -1
                        prepareServerMap(req['bankId'])
                        if req['operation'] == 0:
                            type = 'Query'
                        else:
                            type = 'Update'
                        clk = logical_clock()
                        nums = reqId.split(".")
                        if int(nums[1]) > 1:
                            while retryLimit: 
                                if await(preReq['reqId'] in responses): retryLimit = False
                                elif timeout(int(resendDelay)): 
                                    tryResending(preReq, type)
                        
                        retryLimit = True
                        idx = findServer(req['operation'], req['bankId'])
                        p = serverProcessList[idx]
                        output("ClientId: " + str(clientId) + " Sending request:" + str(req['reqId']) + " to server: " + str(idx))
                        if(req['simFail'] == 1):
                            output("ClientId: " + str(clientId) + " Simulating message failure between client-server")
                        else:
                            send((type, req), to=p) 
                        preReq = req
                        currDelay = int(time.time())
                        currRetriesCnt = 1
                    while retryLimit: 
                        if await(preReq['reqId'] in responses): pass
                        elif timeout(resendDelay): 
                            tryResending(preReq, type)
                    retryLimit = True

        await(False)                                                            # will keep the client process alive

    # callback function to recieve the reponse back from the server
    # will append the response to the "responses" list
    def receive(msg=('Response', res), from_=p):
        output("ClientId: " + str(clientId) + " Received response from server for request: " + str(res['reqId']))
        output("ClientId: " + str(clientId) + " Current Balance: " + str(res['currBal']))
        responses[res['reqId']] = res           # add the received response to the responses object
        # output("last received updated: " + lastRecv)
        output("ClientId: " + str(clientId) + " Responses: " + json.dumps(responses))

    # handle the msg resend logic
    def tryResending(preReq, type):
        if extendChainSleepFlag == 0:
            output("ClientId: " + str(clientId) + " sleeping while the extend chain completes")
            if await(extendChainSleepFlag == 1): pass
            extendChainSleepFlag = -1
            output("ClientId: " + str(clientId) + " awakes after receiing the message")
        
        output("ClientId: " + str(clientId) + " Request timed out. " + str(preReq['reqId']))
        currTime = int(time.time())
        if currTime - currDelay > resendDelay:
            if currRetriesCnt < numRetries:
                output("ClientId: " + str(clientId) + " Checking with tail whether operation already performed: " + str(preReq['reqId']))
                # Check to see if update opr has already been performed
                data = {
                    "checkLog" : 1,
                    "reqId" : preReq['reqId']
                    };  
                idx = findServer(4, preReq['bankId'])
                p = serverProcessList[idx]
                send(('CheckLog', preReq), to=p)
                if await(checkLogFlag == -1): pass          # Wait to get the response from tail if the request has been performed
                elif timeout(5): pass                       # break if nothing received till 5 secs
                
                if checkLogFlag == 0:
                    output("ClientId: " + str(clientId) + " Request not performed at the tail: " + str(preReq['reqId']))
                    output("ClientId: " + str(clientId) + " Performing request again: " + str(preReq['reqId']))
                    checkLogFlag = -1
                    idx = findServer(preReq['operation'], preReq['bankId'])
                    p = serverProcessList[idx]
                    if(preReq['simFail'] == 1):
                        output("ClientId: " + str(clientId) + " Simulating message failure between client-server")
                    else:
                        output("ClientId: " + str(clientId) + " Resending request: " + str(preReq['reqId']))
                        send((type, preReq), to=p) 
                    currDelay = int(time.time())
                    currRetriesCnt += 1
                elif checkLogFlag == 1:
                    checkLogFlag = -1
            else:
                retryLimit = False
                output("ClientId: " + str(clientId) + " Number of retries " + str(currRetriesCnt) + " exceeded the limit " + str(numRetries) + " Aborting request " + str(preReq['reqId']))
        
    # callback handler for check log
    def receive(msg=('CheckLog', res), from_=p):
        output("ClientId: " + str(clientId) + " Received check log response " + json.dumps(res))
        checkLogFlag = res['checkLog']
        if checkLogFlag == 1:
            output("ClientId: " + str(clientId) + " Received response from server for request: " + str(res['reqId']))
            output("ClientId: " + str(clientId) + " Current Balance: " + str(res['currBal']))
            responses[res['reqId']] = res           # add the received response to the responses object
            output("ClientId: " + str(clientId) + " Responses: " + json.dumps(responses))

    # update the chain old in case of chain extension
    # or sleep for the time period the chain is getting extended
    def receive(msg=('ExtendChain', res), from_=p):
        output("ClientId: " + str(clientId) + " received extained chain request: " + json.dumps(res))
        if res['extendChain']['flag'] == 0:
            extendChainSleepFlag = 0
        elif res['extendChain']['flag'] == 1:
            server = res['extendChain']['server']
            extendChainSleepFlag = 1
            bankId = res['extendChain']['bankId']
            bankServerMap[bankId]['tailServer'] = server
 
    # update the tail/head server for the respective banks in case of failure
    def receive(msg=('Failure', res), from_=p):
        output("ClientId: " + str(clientId) + " received failure request")
        bankId = res['failure']['bankId']
        server = res['failure']['server']
        if res['failure']['type'] == 'tail':
            bankServerMap[bankId]['tailServer'] = server
        elif res['failure']['type'] == 'head':
            bankServerMap[bankId]['headServer'] = server
           
   
# Class for the master process to handle failure and chain extension
class Master(process):
    # setup function for the client process
    def setup(bankClientMap, bankServerMap, heartBeatDelay, clients, servers):
        self.serverTimeStampMap = {}    # mapping of serverId to the entries in the heap
        self.serverTimeStampHeap = []   # list of entries arranged in a heap based upon the timestamp
        self.REMOVED = '<removed-task>'     # place holder for a removed task
        self.counter = itertools.count()    # unique sequence count
        self.clientList = list(clients)
        self.serverList = list(servers)
        self.succSeqNum = -1
        self.extendChainFlag = -1
    
    # main function to read the payload file and
    # invoke requests to the server
    def main():
        output("Master: Master process started")
        while True:                     # probe for server failure every second
            if(await(False)): pass
            elif timeout(1):
                probeServerFailure()

    # utility functions for heap/dict data structure for storing and retrieving the timestamp
    # this function will add a new entry for the serverId if one doesn't exist, else will update the existing entry
    def addTimeStamp(server, timestamp = 0):
        serverId = server['serverId']
        # output("ServerId: "  + str(serverId))
        if serverId in serverTimeStampMap:
            removeTimeStamp(server)
        count = next(counter)
        entry = [timestamp, count, server]
        serverTimeStampMap[server['serverId']] = entry
        heapq.heappush(serverTimeStampHeap, entry)

    # will remove the existing entry from the dist
    def removeTimeStamp(server):
        entry = serverTimeStampMap.pop(server['serverId'])
        entry[-1] = REMOVED

    # will pop of the first entry from the heap
    def popTimeStamp():
        while serverTimeStampHeap:
            timestamp, count, server = heapq.heappop(serverTimeStampHeap)
            if server is not REMOVED:
                del serverTimeStampMap[server['serverId']]
                return [server, timestamp]
            # raise KeyError('pop from an empty priority queue')  


    # If a server entry is already there in the heap, just update the new timestamp
    # else add a new entry for that server in the server timestamp list and heap
    def receive(msg=('HeartBeat', server), from_=p):
        output("Master: Received heart beat msg from server: " + str(server['serverId']))
        addTimeStamp(server, int(time.time())) 
   
    # probe the heap data structure to check if any server has failed
    def probeServerFailure():
        serverObj = popTimeStamp()
        if serverObj is None :
            return
        server = serverObj[0]
        timestamp = serverObj[1]
        if(int(time.time()) - timestamp > 5):
            output("Master: ServerId: " + str(server['serverId']) + " failed")
            handleServerFailure(server)
        else:
            addTimeStamp(server, timestamp)
           
    # handle server failure
    # notify the respective servers
    # notify the clients
    def handleServerFailure(server):
        serverId = server['serverId']
        bankId = server['bankId']
        type = server['type']
        output("Master: handling the server failure for ServerId: " + str(serverId)) 
        if type == 0:
            newHead = updateChain(bankId, serverId, type)
            output("Master: New head upated. ServerId: " + str(newHead))
            payload = { 
                "failure" : { 
                    "type" : "head",
                    "server" : serverList[newHead],
                    "bankId" : bankId
                } 
            }
            notifyClient(bankId, payload)
            send(('Failure', payload), to=serverList[newHead])
        elif type == 1:
            newSuccPred = updateChain(bankId, serverId, type)
            output("Master: New relation: " + json.dumps(newSuccPred))
            payload = {
                "failure" : {
                    "type" : "predecessor",
                    "server" : serverList[newSuccPred[0]]
                }
            }
            send(('Failure', payload), to=serverList[newSuccPred[1]])
            await(succSeqNum != -1)  # await till successor send seqNum
            payload['failure']['type'] = "successor"
            payload['failure']['server'] = serverList[newSuccPred[1]]
            payload['failure']['seqNum'] = succSeqNum
            send(('Failure', payload), to=serverList[newSuccPred[0]])
            succSeqNum = -1
            # TODO: implement the logic for predecessor failure while recovery
        elif type == 2:
            newTail = updateChain(bankId, serverId, type)
            output("Master: New Tail upated. ServerId: " + str(newTail))
            payload = {
                "failure" : { 
                    "type" : "tail",
                    "server" : serverList[newTail],
                    "bankId" : bankId
                } 
            }
            notifyClient(bankId, payload)
            send(('Failure', payload), to=serverList[newTail])
        else:
            output("Master: Error unknown server type")

    # notify clients for the server failure
    def notifyClient(bankId, payload):
        output("Master: entering notify clients.") 
        for client in bankClientMap[bankId]:
            output("Master: Notifying client of bankId: " + str(bankId) + " dest: " + str(client))
            if 'extendChain' in payload.keys():
                output("Master: Extend Chain operation being communicated with client.")
                send(('ExtendChain', payload), to=clientList[client])
            else:
                output("Master: Server failure being communicated with clients.")
                send(('Failure', payload), to=clientList[client])

    # update server chain
    def updateChain(bankId, serverId, type):
        output("Master: Updating the chain for the bank: " + str(bankId) + " server " + str(serverId))
        if type == 0:
            del bankServerMap[bankId][0]
            return bankServerMap[bankId][0]
        elif type == 1:
            i = 0
            for server in bankServerMap[bankId]:
                if serverId == server:
                    del bankServerMap[bankId][server]
                    return [bankServerMap[bankId][i-1], bankServerMap[bankId][i]]
                i += 1
        elif type == 2:
            length = len(bankServerMap[bankId])
            del bankServerMap[bankId][length - 1]
            return bankServerMap[bankId][length - 2]
        output("Master: Updated the chain for the bank: " + str(bankId)) 
   
    # Received predecessor updation from the new tail
    def receive(msg=('ExtendChainAck', data), from_=p):
        output("Master: received extend chain ack " + json.dumps(data))
        extendChainFlag = data['ack']

    # Add a new server to the chain as the new tail
    def receive(msg=('AddToChain', data), from_=p):
        serverId = data['extendChain']['serverId']
        bankId = data['extendChain']['bankId']
        output("Master: Adding new server for the bank " + str(bankId) + " to the chain. Server Id " + str(serverId))
        
        # notify all the client for the corresponding bank 
        data = {'extendChain': { 'flag' : 0 }}              # Make the client sleep
        notifyClient(bankId, data) 
       
        servers = bankServerMap[bankId]
        oldTail = servers[len(servers) - 1]                 # extract the old tail
     
        # Calling extend chain on new tail
        data = {}
        data['extendChain'] = 1 
        data['type'] = 2
        data['predecessor'] = serverList[oldTail] 
        output("Master: notifying the new tail: " + str(serverId))
        send(('ExtendChain', data), to=serverList[serverId])

        output("Master: " + str(extendChainFlag))
        if await(extendChainFlag == 1): pass
        elif timeout(5): pass                       # wait for 5 secs to receive the response
         
        if extendChainFlag == -1:
            output("Master: Cannot extend chain. The new server failed.")
            awakeClient(bankId, oldTail)
            return
        elif extendChainFlag == 1:
            output("Master: New tail activated successfully.")
            # Calling extend chain on old tail, to notify that the chain has extended
            extendChainFlag = -1
       
        # notify the old tail of its new successor
        output("Master: New server added to the chain successfully")
        data = {}
        data['extendChain'] = 2
        data['type'] = 1
        data['successor'] = serverList[serverId]
        output("Master: Notifying old tail of chain extension")
        send(('ExtendChain', data), to=serverList[oldTail])         
      
        if await(extendChainFlag == 2): pass
        elif timeout(5): pass
       
        if extendChainFlag == -1: 
            output("Master: Cannot extend chain. The new server failed. Reverting back to the old chain")
            data = {}
            data['extendChain'] = -1
            data['type'] = 2
            output("Master: Notifying the old tail of chain extension failure")
            send(('ExtendChain', data), to=serverList[oldTail])
            awakeClient(bankId, oldTail)
            return
        elif extendChainFlag == 2:
            output("Master: New Tail synchronized successfully")
            bankServerMap[bankId].append(serverId)
            awakeClient(bankId, serverId)
            extendChainFlag = -1
         
    # callback to handle the response from the successor in case of internal failure
    def receive(msg=('Failure', res), from_=p):
        output("Master: received the seqNum from the successor")
        succSeqNum = res['seqNum'] 

    # awake client processes
    def awakeClient(bankId, tail):
        data = {}
        extendChain = {}
        extendChain['type'] = 'tail'
        extendChain['server'] = tail
        extendChain['bankId'] = bankId
        extendChain['flag'] = 1
        data['extendChain'] = extendChain
        output("Master: notifying clients for bank: " + str(bankId))
        notifyClient(bankId, data)

# count number of client and server processes
# using the config file
def countProcesses(config):
    count = {}
    servers = 0
    for c in config:
        for bank in c['bank']:
            servers += len(bank['servers'])
        count['total_servers'] = servers
        count['total_clients'] = len(c['client'])
    print('Bootstraping: Calculating #  of processes: ' + json.dumps(count))
    return count

# main function for bootstraping the servers and clients
def main():
    config(clock='Lamport')

    print('Bootstraping: loading and parsing the config file')
    # load and parse the 'config' and 'payload' files in JSON format

    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/randomPayload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/samePayload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/payload.json')
    #dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/inconsistentHistoryPayload.json')
    dataFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/payloadMsgDrop.json')
    data = json.load(dataFile, cls=ConcatJSONDecoder)
    cfgFile = open('/home/ppandey/async/cse535/chain_rep_distalgo/config.json')
    config = json.load(cfgFile, cls=ConcatJSONDecoder)
    
    # calculate the number of client and servers needed
    count = countProcesses(config)
    
    # create the respective # of processes
    servers = new(Server, num = count['total_servers'])
    clients = new(Client, num = count['total_clients'])
    
    # create a master process
    master = new(Master, num = 1)

    # create a list of clients config objects
    clientMap = []
    for c in config:
        for client in c['client']:
            clientMap.append(client)

    # create a list of server config objects
    extendchainConfig  = []
    serverMap = []
    bankServerMap = {}  # list of bank vs servers
    for c in config:
        for bank in c['bank']:
            serverList = []
            for s in bank['servers']:
                if s['extendChain'] == 0:
                    conf = {}
                    conf['bankId'] = bank['bankId']
                    conf['type'] = s['type']
                    conf['serverId'] = s['serverId']
                    conf['startupDelay'] = s['startupDelay']
                    conf['serverLifeTime'] = s['serverLifeTime']
                    conf['extendChain'] = s['extendChain']
                    serverMap.append(conf)
                    serverList.append(s['serverId'])
                else:
                    conf = {}
                    conf['bankId'] = bank['bankId']
                    conf['type'] = 2
                    conf['serverId'] = s['serverId']
                    conf['startupDelay'] = s['startupDelay']
                    conf['serverLifeTime'] = s['serverLifeTime']
                    conf['extendChain'] = s['extendChain']
                    extendchainConfig.append(conf)
            bankServerMap[bank['bankId']] = serverList

    # create a list of bank vs clients
    bankClientMap = {}
    for c in config:
        for bank in c['bank']:
            clientList = []
            for client in bank['clients']:
                clientList.append(client['clientId'])
            bankClientMap[bank['bankId']] = clientList
    
    heartBeatDelay = 0
    for c in config:
        m = c['master']
        heartBeatDelay = m['heartBeatDelay']
        # print(str(heartBeatDelay))

    # setup servers/clients
    print('Bootstraping: Setting up client/server processes')
    i = 0
    serList = list(servers)
    # print(json.dumps(serverMap))
    for config in serverMap:
        # print("Setup Server: " + str(config['serverId']))
        if config['type'] == 0:
            setup(serList[config['serverId']], (clients, master, config, None, serList[i+1]))
        elif config['type'] == 2:
            setup(serList[config['serverId']], (clients, master, config, serList[i-1], None))
        else:
            setup(serList[config['serverId']], (clients, master, config, serList[i-1], serList[i+1]))
        i += 1

    # setup processed for chain extension
    for config in extendchainConfig:
        setup(serList[config['serverId']], (clients, master, config, None, None))

    # setup the client processes
    # the "clientId" of the client will be the index of the 
    # client process in the "clients" list
    cltList = list(clients)
    for process, config in zip(cltList, clientMap):
        setup({process}, (servers, config, data))

    # setup master process
    setup(master, (bankClientMap, bankServerMap, heartBeatDelay, clients, servers))

    print('Bootstraping: Starting client/server processes')
    # Start the server and client processes
    start(master)
    start(servers)
    start(clients)

