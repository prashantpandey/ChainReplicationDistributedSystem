/*
 Server pseudo code

 General Data-Structures

 	ServertType type;
 	Server successor;
 	Server predecessor;

 	class SyncMsgContext  {
 		string seqNum;
 		Request req;
 		Operation opr;
		Reply reply;
 	}

	List sentReq {  RequestContext }			// we can use it as a sent updates which are sent to the successor 
															// but are not received by the tail
	List historyReq { RequestContext }

	class Request {
		string reqId,
		string bankId;
		string accountNum;
		float amount;
		string destBankId;
		string destAccountNum;
	}

	enum Outcome { Processed, InconsistentWithHistory, InsufficientFunds }

	class Reply {
		string reqId;
		Outcome outcome;
		float bal;
	}

	enum Operation { GetBalance, Deposit, Withdraw, Transfer }
	enum serverRelation { successor, predecessor }
	enum serverType { Head, Internal, Tail }

 Events:

 	- sync 			// receive sync requests from predecessor server
 					// apply the update
 					// propagate the update to the successor
	- receive 		// event to recieve the requests from the clients.
					// The requests can have four kind of operations.
					// Update request will be sent to the head server. Head will send sync message to next server in the chain.
					// Query request will be sent to the tail server. The tail will send the reply back to the client.
					// assign a unique sequence number to each received request.
		args:	Operation, Request

	- failure		// event to handle the failure of any adjecent server in the chain
					// this will just update the current value of the successor/predecessor/type
					// if the received server relation is predecessor
					// it will also send the master the sequence number of the last request it received
					// If the received server relation is successor, then send all the updates greater than the received seqNum to the new successor
					// the predecessor will halt until it sends all the pending updates to the successor
		args:	serverId, serverRelation

	- ack			// will receive the ack from the next server in the chain (successor)
					// delete all the req from the pendingReq list smaller than the seqNum received
					// send the ack to the predecessor
		args:	RequestContext


 Functions:
	- failure 			// If the server has exceeded its sent or receive count then it should terminate
						// It has to check whether the configuration is set to "unbound", under which it won't terminate
						// This function will do nothing but exit(0)


	- sendHeartBeat		// send the heart beat signal to the master
		args:	serverId

*/ 

	event sync(SyncContextMsg msg):
		applyUpdates(msg);
		if(successor != null)
			sendSyncUpdate(successor, msg);
		else
			sendResponse(msg.reply);
	end

	event receive(Operation opr, Request req):
		switch(opr):
			case GetBalance:
				bal = retrieveBal(req);
				reply = new Reply(req.reqId, Outcome.Processed, bal);
				sendResponse(reply);
				break;
			
			case Deposit:
				flag = checkIfAlreadyProcessed(req);
				if(!flag):
					bal  = applyDeposit(req);
					reply = new Reply(req.reqId, Outcome.Processed, bal);
				else {
					bal = retrieveBal(req);
					reply = new Reply(req.reqId, Outcome.InconsistentWithHistory, bal);
				}
				seqNum = generateSeqNum();
				msg = new SyncContextMsg(seqNum, req, opr, reply);
				sendSyncUpdate(successor, msg);
				break;

			case Withdraw:
				flag = checkIfAlreadyProcessed(req);
				if(!flag):
					bal  = applyWithdraw(req);
					if(bal < 0) {
						bal = retrieveBal(req);
						reply = new Reply(req.reqId, Outcome.InsufficientFunds, bal);
					}
					else {
						reply = new Reply(req.reqId, Outcome.Processed, bal);
					}
				else {
					bal = retrieveBal(req);
					reply = new Reply(req.reqId, Outcome.InconsistentWithHistory, bal);
				}
				seqNum = generateSeqNum();
				msg = new SyncContextMsg(seqNum, req, opr, reply);
				sendSyncUpdate(successor, msg);
				break;
					
			case Transfer:
				flag = checkIfAlreadyProcessed(req);
				if(!flag):
					bal = applyWithdraw(req);
					if(bal < 0) {
						bal = retrieveBal(req);
						reply = new Reply(req.reqId, Outcome.InsufficientFunds, bal);
					}
					else {
						req = new Request(reqId, bankId, accountNum, amount, null, null);
						head = getHead(req.destBankId);
						reply  = sendReq(Operation.Deposit, req, head);
					}
				else {
					bal = retrieveBal(req);
					reply = new Reply(req.reqId, Outcome.InconsistentWithHistory, bal);
				}
				seqNum = generateSeqNum();
				msg = new SyncContextMsg(seqNum, req, opr, reply);
				sendSyncUpdate(successor, msg);
				break;
		failure();
	end

	event failure(serverId, serverRelation, seqNum):
		switch(serverRelation):
			case Successor:
				successor = serverId;
				sendUpdates(seqNum, successor);		// send all the updates greater than seqNum to the new successor
				break;
			case predecessor:
				predecessor = serverId;
				seqNum = retrieveLastSeqNum();
				sendAckMaster(seqNum);
				break;
	end

	event ack (seqNum):
		deleteReq(seqNum); 			// delete all the requests from the sentRea List smaller than seqNum
		sendAck(seqNum, predecessor);
	end


	function failure:				// called after every receive event
		if(currSendCnt >= MaxSendCnt || currReceiveCnt >= MaxReceiveCnt)
			exit(0)
	end


	function sendHeartBeat:			// called every second
		sendAckMaster(ownServerId);
	end


